import library.location
from library.location import Location

import csv
import datetime
import io
import os
import re
import shutil
import zipfile

import logging
log = logging.getLogger(__name__)

BROKEN_Y = '\u0438\u0306'  # й из 2 символов
PROPER_Y = '\u0439'  # й из 1 символа


class UdrPath(object):
    def __init__(self, *path):
        self.__Path = path

    def __call__(self, *path, **kws):
        resPath = self.__Path + path
        resPath = library.location.udr(*resPath)
        if kws.get('create_missing_dir') is True and not os.path.isdir(resPath):
            log.warn('Create missing %s', resPath)
            os.mkdir(resPath)
        return resPath


def walkFiles(
    dirName,
    extensions=[],
    dirsOnly=False,
    recursive=True,
    regexp=None,
):
    logName = 'dirs' if dirsOnly else 'files'
    log.debug(f'Looking for {logName} of types {extensions} in {dirName} matching {regexp}')
    count = 0
    if not os.path.exists(dirName):
        log.error('Path %r is missing', dirName)

    if regexp is not None:
        if not isinstance(regexp, list):
            regexps = [regexp]
        else:
            regexps = regexp
    else:
        regexps = []

    regexps = [r.replace(BROKEN_Y, PROPER_Y) for r in regexps]

    iterable = os.walk(dirName)
    if not recursive:
        iterable = [next(iterable)]
    for root, dirs, files in iterable:
        if dirsOnly:
            for directory in dirs:
                if not regexps or any(re.match(regexp, directory) for regexp in regexps):
                    if directory.startswith('~$'):
                        log.warn('Skipping %s in %s', directory, root)
                    else:
                        count += 1
                        res = os.path.join(root, directory).replace(BROKEN_Y, PROPER_Y)
                        yield res
        else:
            for filename in files:
                if not extensions or any(filename.endswith(extension) for extension in extensions):
                    if not regexps or any(re.match(regexp, filename) for regexp in regexps):
                        if filename.startswith('~$'):
                            log.warn('Skipping %s in %s', filename, root)
                        else:
                            count += 1
                            res = os.path.join(root, filename).replace(BROKEN_Y, PROPER_Y)
                            yield res
    log.debug('Found %d %s in %s', count, logName, dirName)


class FileWriter(object):
    def __init__(self, nameFilter=None):
        self.NameFilter = nameFilter
        self.WrittenFiles = set()

    def NotMatches(self, filename):
        return self.NameFilter and self.NameFilter not in filename

    def Write(self, *pathParts, **kwargs):
        assert pathParts
        filename = os.path.join(*pathParts)
        assert filename

        text = kwargs.get('text')
        assert text

        self.WrittenFiles.add(filename)
        log.info('Saving file %s', filename)
        with open(filename, 'w') as f:
            f.write(text.strip())
            f.write('\n% autogenerated\n')

    def ShowManual(self, extensions=[]):
        allFiles = set()
        dirs = set(os.path.dirname(filename) for filename in self.WrittenFiles)
        for dirname in dirs:
            for filename in walkFiles(dirname, extensions=extensions):
                allFiles.add(filename)

        manualFiles = sorted(allFiles - self.WrittenFiles)
        log.info('Got %d manual files in %r', len(manualFiles), sorted(dirs))
        for index, manualFile in enumerate(manualFiles):
            log.info('  Manual file %3d: %s', index, manualFile)


class FileCopier(object):
    def __init__(self, source_file, destination_dir=None):
        assert os.path.exists(source_file)
        assert os.path.isfile(source_file)
        self._source_file = source_file
        log.info('Using source file \'%s\'', self._source_file)

        if destination_dir is None:
            self._destination_dir = None
        else:
            self.SetDestinationDir(destination_dir)

    def SetDestinationDir(self, destination_dir):
        assert os.path.exists(destination_dir)
        assert os.path.isdir(destination_dir)
        self._destination_dir = destination_dir
        log.info('Using destination dir \'%s\'', self._destination_dir)

    def CreateFile(self, destination_file):
        if self._destination_dir:
            destination_path = os.path.join(self._destination_dir, destination_file)
        else:
            destination_path = destination_file

        # never overwrite file
        if not os.path.exists(destination_path):
            log.info('Creating \'%s\' from template', destination_path)
            shutil.copy(self._source_file, destination_path)
        else:
            log.debug('File %s already exists', destination_path)


def is_older(first_file, second_file):
    assert os.path.exists(first_file)
    assert os.path.isfile(first_file)
    if not os.path.exists(second_file):
        return False
    elif os.path.isdir(second_file):
        raise RuntimeError(f'\'{second_file}\' is not a file')
    else:
        first_mtime = os.path.getmtime(first_file)
        second_mtime = os.path.getmtime(second_file)
        return first_mtime < second_mtime


class ZoomRenamer:
    def __init__(self, root):
        assert os.path.exists(root)
        assert os.path.isdir(root)
        self._root = root

    def RenameOne(self, dir_name):
        assert os.path.exists(dir_name)
        assert os.path.isdir(dir_name)

        dir_base = os.path.basename(dir_name)
        log.info(f'Renaming zoom dir {dir_base}')
        src_date_fmt = '%Y-%m-%d %H.%M.%S'
        dst_date_fmt = '%Y-%m-%d %H-%M'
        dt = datetime.datetime.strptime(dir_base[:4 + 3 + 3 + 3 + 3 + 3], src_date_fmt)
        date = dt.strftime(dst_date_fmt)
        dst_dir = os.path.join(self._root, f'{date} - zoom')
        assert not os.path.exists(dst_dir)

        if os.path.exists(os.path.join(self._root, dir_base, 'double_click_to_convert_01.zoom')):
            log.warn(f'Still converting {dir_name} to mp4')
            return

        for src_base, dst_base in [
            ('audio_only.m4a', f'{date} - аудио.m4a'),
            ('chat.txt', f'{date} - чат - en.txt'),
            ('meeting_saved_chat.txt', f'{date} - чат - ru.txt'),
            ('playback.m3u', f'{date} - playback.m3u'),
            ('zoom_0.mp4', f'{date} - запись.mp4'),
        ]:
            src_file = os.path.join(self._root, dir_base, src_base)
            dst_file = os.path.join(self._root, dir_base, dst_base)
            if os.path.exists(src_file) and not os.path.exists(dst_file):
                log.info(f'Moving file {src_file} to {dst_file}')
                shutil.move(src_file, dst_file)

        log.info(f'Moving dir {dir_name} to {dst_dir}')
        shutil.move(dir_name, dst_dir)


class FileMover:
    def __init__(self, prefix=None):
        self._prefix = prefix

    def Move(self, re=None, source=None, destination=None, matching=None):
        src_list = [i for i in [self._prefix, source] if i]
        dst_list = [i for i in [self._prefix, source, destination] if i]
        src_dir = os.path.join(*src_list).replace(BROKEN_Y, PROPER_Y)
        dst_dir = os.path.join(*dst_list).replace(BROKEN_Y, PROPER_Y)
        log.info(f'Moving files from {src_dir} (recursive) to {dst_dir} (flat)')
        assert os.path.exists(src_dir)
        assert os.path.isdir(src_dir)
        assert os.path.exists(dst_dir)
        assert os.path.isdir(dst_dir)
        for src_file in walkFiles(source, regexp=re):
            assert os.path.exists(src_file)
            assert os.path.isfile(src_file)
            basename = os.path.basename(src_file)
            if matching is None or matching(basename):
                dst_file = os.path.join(dst_dir, basename)
                assert not os.path.exists(dst_file)
                log.info(f'Moving file {basename!r} to {dst_file}')
                shutil.move(src_file, dst_file)
            else:
                log.debug(f'File {basename!r} does not match')


class ZippedCsv:
    def __init__(self, filename):
        assert filename.endswith('.csv.zip')
        self._filename = filename

    def ReadDicts(self):
        assert os.path.exists(self._filename), f'No file {self._filename}'
        assert os.path.isfile(self._filename), f'Is not file {self._filename}'
        with zipfile.ZipFile(self._filename, 'r') as zfile:
            assert len(zfile.namelist()) == 1
            for file in zfile.namelist():
                log.debug(f'Reading {file}')
                data = io.StringIO(zfile.read(file).decode('utf8'))
                reader = csv.DictReader(data)
                for row in reader:
                    yield row
