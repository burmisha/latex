import library.location
from library.location import Location
from library.logging import cm, color

import csv
import datetime
import io
import os
import re
import shutil
import zipfile

import logging
log = logging.getLogger(__name__)

BROKEN_Y = '\u0438\u0306'  # й из 2 символов
PROPER_Y = '\u0439'  # й из 1 символа
BROKEN_YO = '\u0435\u0308'  # ё из 2 символов
PROPER_YO = '\u0451'  # ё из 1 символа


class UdrPath(object):
    def __init__(self, *path):
        self.__Path = path

    def __call__(self, *path, **kws):
        resPath = self.__Path + path
        resPath = library.location.udr(*resPath)
        if kws.get('create_missing_dir') is True and not os.path.isdir(resPath):
            log.warn('Create missing %s', resPath)
            os.mkdir(resPath)
        return resPath


def path_is_ok(value, raise_on_error=True):
    invalid_substrings = [BROKEN_Y, BROKEN_YO, '–', '—']
    for substring in invalid_substrings:
        if substring in value:
            pos = value.find(substring)
            msg = value[:pos] + cm(value[pos:pos+len(substring)], bg=color.Red) + value[pos+len(substring):]
            log.info(f'Broken {substring} in {msg}')
            if raise_on_error:
                raise RuntimeError(f'Broken {substring}')
    return True


def is_dir(dir_name):
    if not path_is_ok(dir_name):
        raise RuntimeError(f'Broken dir name {dir_name}')
    if not os.path.exists(dir_name):
        raise RuntimeError(f'No dir {dir_name}')
    if not os.path.isdir(dir_name):
        raise RuntimeError(f'Not dir {dir_name}')
    return True


def is_file(file_name):
    if not path_is_ok(file_name):
        raise RuntimeError(f'Broken file name {file_name}')
    if not os.path.exists(file_name):
        raise RuntimeError(f'No file {file_name}')
    if not os.path.isfile(file_name):
        raise RuntimeError(f'Not file {file_name}')
    return True


def walkFiles(
    dirName,
    extensions=[],
    dirsOnly=False,
    recursive=True,
    regexp=None,
):
    logName = 'dirs' if dirsOnly else 'files'
    log.debug(f'Looking for {logName} of types {extensions} in {dirName} matching {regexp}')
    count = 0
    if not os.path.exists(dirName):
        log.error('Path %r is missing', dirName)

    if regexp is not None:
        if not isinstance(regexp, list):
            regexps = [regexp]
        else:
            regexps = regexp
    else:
        regexps = []

    regexps = [r.replace(BROKEN_Y, PROPER_Y) for r in regexps]

    iterable = os.walk(dirName)
    if not recursive:
        iterable = [next(iterable)]
    for root, dirs, files in iterable:
        if dirsOnly:
            for directory in dirs:
                if not regexps or any(re.match(regexp, directory) for regexp in regexps):
                    if directory.startswith('~$'):
                        log.warn('Skipping %s in %s', directory, root)
                    else:
                        count += 1
                        res = os.path.join(root, directory).replace(BROKEN_Y, PROPER_Y)
                        yield res
        else:
            for filename in files:
                if not extensions or any(filename.endswith(extension) for extension in extensions):
                    if not regexps or any(re.match(regexp, filename) for regexp in regexps):
                        if filename.startswith('~$'):
                            log.warn('Skipping %s in %s', filename, root)
                        else:
                            count += 1
                            res = os.path.join(root, filename).replace(BROKEN_Y, PROPER_Y)
                            yield res
    log.debug('Found %d %s in %s', count, logName, dirName)


class FileWriter(object):
    def __init__(self, nameFilter=None):
        self.NameFilter = nameFilter
        self.WrittenFiles = set()

    def NotMatches(self, filename):
        return self.NameFilter and self.NameFilter not in filename

    def Write(self, *pathParts, **kwargs):
        assert pathParts
        filename = os.path.join(*pathParts)
        assert filename

        if self.NotMatches(os.path.basename(filename)):
            log.info('Skipping %s', filename)
            return

        text = kwargs.get('text')
        assert text

        self.WrittenFiles.add(filename)
        log.info('Saving file %s', filename)
        with open(filename, 'w') as f:
            f.write(text.strip())
            f.write('\n% autogenerated\n')

    def ShowManual(self, extensions=[]):
        allFiles = set()
        dirs = set(os.path.dirname(filename) for filename in self.WrittenFiles)
        for dirname in dirs:
            for filename in walkFiles(dirname, extensions=extensions):
                allFiles.add(filename)

        manualFiles = sorted(allFiles - self.WrittenFiles)
        log.info('Got %d manual files in %r', len(manualFiles), sorted(dirs))
        for index, manualFile in enumerate(manualFiles):
            log.info('  Manual file %3d: %s', index, manualFile)


class FileCopier(object):
    def __init__(self, source_file, destination_dir=None):
        assert os.path.exists(source_file), f'No file {source_file}'
        assert os.path.isfile(source_file), f'Not file {source_file}'
        self._source_file = source_file
        log.info(f'Using template {self._source_file}')

        if destination_dir is None:
            self._destination_dir = None
        else:
            self.SetDestinationDir(destination_dir)

    def SetDestinationDir(self, destination_dir):
        assert os.path.exists(destination_dir), f'No dir {destination_dir}'
        assert os.path.isdir(destination_dir), f'Not dir {destination_dir}'
        self._destination_dir = destination_dir
        log.info('Using destination dir \'%s\'', self._destination_dir)

    def CreateFile(self, destination_file):
        if self._destination_dir:
            destination_path = os.path.join(self._destination_dir, destination_file)
        else:
            destination_path = destination_file

        # never overwrite file
        if not os.path.exists(destination_path):
            log.info(f'Creating {destination_path} from template')
            shutil.copy(self._source_file, destination_path)
        else:
            log.info('File %s already exists', destination_path)


def is_older(first_file, second_file):
    assert os.path.exists(first_file)
    assert os.path.isfile(first_file)
    if not os.path.exists(second_file):
        return False
    elif os.path.isfile(second_file):
        first_mtime = os.path.getmtime(first_file)
        second_mtime = os.path.getmtime(second_file)
        return first_mtime < second_mtime
    else:
        raise RuntimeError(f'\'{second_file}\' is not a file')


class ZoomRenamer:
    def __init__(self, root):
        assert os.path.exists(root), f'No dir {root}'
        assert os.path.isdir(root), f'Not dir {root}'
        self._root = root

    def RenameOne(self, dir_name):
        assert os.path.exists(dir_name), f'No dir {dir_name}'
        assert os.path.isdir(dir_name), f'Not dir {dir_name}'

        dir_base = os.path.basename(dir_name)
        log.info(f'Renaming zoom dir {dir_base}')
        src_date_fmt = '%Y-%m-%d %H.%M.%S'
        dst_date_fmt = '%Y-%m-%d %H-%M'
        dt = datetime.datetime.strptime(dir_base[:4 + 3 + 3 + 3 + 3 + 3], src_date_fmt)
        date = dt.strftime(dst_date_fmt)
        dst_dir = os.path.join(self._root, f'{date} - zoom')
        assert not os.path.exists(dst_dir), f'Already exists {dst_dir}'

        if os.path.exists(os.path.join(self._root, dir_base, 'double_click_to_convert_01.zoom')):
            log.warn(f'Still converting {dir_name} to mp4')
            return

        for src_base, dst_base in [
            ('audio_only.m4a', f'{date} - аудио.m4a'),
            ('chat.txt', f'{date} - чат - en.txt'),
            ('meeting_saved_chat.txt', f'{date} - чат - ru.txt'),
            ('playback.m3u', f'{date} - playback.m3u'),
            ('zoom_0.mp4', f'{date} - запись.mp4'),
        ]:
            src_file = os.path.join(self._root, dir_base, src_base)
            dst_file = os.path.join(self._root, dir_base, dst_base)
            if os.path.exists(src_file) and not os.path.exists(dst_file):
                log.info(f'Moving file {src_file} to {dst_file}')
                shutil.move(src_file, dst_file)

        log.info(f'Moving dir {dir_name} to {dst_dir}')
        shutil.move(dir_name, dst_dir)


class FileMover:
    def __init__(self, prefix=None):
        self._prefix = prefix

    def Move(self, re=None, source=None, destination=None, matching=None):
        src_list = [i for i in [self._prefix, source] if i]
        dst_list = [i for i in [self._prefix, source, destination] if i]
        src_dir = os.path.join(*src_list).replace(BROKEN_Y, PROPER_Y)
        dst_dir = os.path.join(*dst_list).replace(BROKEN_Y, PROPER_Y)
        log.info(f'Moving files from {src_dir} (recursive) to {dst_dir} (flat)')
        assert os.path.exists(src_dir), f'No dir {src_dir}'
        assert os.path.isdir(src_dir), f'Not dir {src_dir}'
        assert os.path.exists(dst_dir), f'No dir {dst_dir}'
        assert os.path.isdir(dst_dir), f'Not dir {dst_dir}'
        for src_file in walkFiles(source, regexp=re):
            assert os.path.exists(src_file), f'No file {src_file}'
            assert os.path.isfile(src_file), f'Not file {dst_dir}'
            basename = os.path.basename(src_file)
            if matching is None or matching(basename):
                dst_file = os.path.join(dst_dir, basename)
                assert not os.path.exists(dst_file), f'Exists {dst_file}'
                log.info(f'Moving file {basename!r} to {dst_file}')
                shutil.move(src_file, dst_file)
            else:
                log.debug(f'File {basename!r} does not match')


class ZippedCsv:
    def __init__(self, filename):
        assert filename.endswith('.csv.zip')
        self._filename = filename

    def ReadDicts(self):
        assert os.path.exists(self._filename), f'No file {self._filename}'
        assert os.path.isfile(self._filename), f'Is not file {self._filename}'
        with zipfile.ZipFile(self._filename, 'r') as zfile:
            assert len(zfile.namelist()) == 1, f'Found too many files in {filename}: {zfile.namelist()}'
            for file in zfile.namelist():
                log.debug(f'Reading {file}')
                data = io.StringIO(zfile.read(file).decode('utf8'))
                reader = csv.DictReader(data)
                for row in reader:
                    yield row
