
\maintext{Обозначения:}\\
\%~--- операция взятия остатка от деления, \\
/~--- деление на число (деление бинарного числа на 2 равносильно отбрасыванию последней цифры), \\
$(\cdot,\cdot).first$~--- первый элемент пары,\\
$\overline{\omega^n} = \omega_1\omega_1\omega_2\omega_2\ldots \omega_n\omega_n$, \\
отметим также, что не проводится различий между сложностью числа и его бинарной записью, т.к. автор не видит содержательного различия в этих понятиях. 

\task{1.1}
(a) $K(0^n|n)\le^+\min\limits_p\{l(p) \colon B(p,n)=0^n\}$, где, например, $ \forall p B(p,n)=0^n$. То есть можно положить $p=\Lambda \Leftrightarrow l(p)=0$. Поэтому   $K(0^n|n)\le^+0 \Leftrightarrow K(0^n|n)=^+0$.
$K(0^n)\le^+\log n$, так как, положив $A(bin\,n)=0^n$, получим то неравенство, ведь $l(bin \, n) = \lceil\log n\rceil <\log n +1$. 
Неравенство $K(2^n)\le^+\log n$ доказывается аналогично, надо лишь заменить $A$, поскольку $2^n=1\underbrace{00\ldots0}_n$, т.е. положить $A(bin\,n)=bin(2^n)$.

(b) Зададим $N$ некоторым образом и введем в рассмотрение следующие величины: $k=\lfloor\log N\rfloor \Leftrightarrow 2^k\le N < 2^{k+1}.\;
		D_k=\{0^r\colon 2^k\le r < 2^{k+1}\}.\; |D_k|=2^k\le N.$ Тогда среди элементов $D_k$ найдется такой $0^n$, что его сложность $K(0^n)> \log |D_k|-1=k-1$, ибо слов длины $N-1$ не хватит для описания всего множества: там слишком много элементов. Причем это $n$ лежит в пределах $2^k\le n < 2^{k+1} \Rightarrow k  > \log n -1$. Т.е. мы построили слово такое, что $K(0^n)>k-1>\log n -2$. Увеличивая $N$, мы можем получить сколь угодно много таких слов. 
		
(c) $K(x|l(x))\le^+K(x)$, ведь положив, что $A(p)=x, l(p)=K(x)$ и рассмотрев алгоритм $\forall y \: B(z,y)=A(z)$, получим $K(x|l(x))\le^+K_B(x|l(x))=K_A(x)=p=K(x)$.
Пусть $B(p,l(x))=x, K(x|l(x))=l(p).$ Рассмотрим алгоритм 
\ml{B\left(\overline{bin(y)}01bin(l(x))p\right)=B(p,l(x))=x, \text{ где } y=l(bin(l(x))) \Rightarrow \\
\Rightarrow l(bin(y))=\lceil \log l(bin(l(x))) \rceil = \lceil \log \lceil \log l(x) \rceil \rceil\le \log (\log l(x) + 1)\le \log \log l(x)+1,}  
тогда \al{ K(x)&\le^+ K_B(x) \le l\left(\overline{bin(y)}01bin(l(x))p\right)\le 2\cdot(\log\log l(x) +1) + 2 + (\log l(x) + 1) + l(p) = \\ 
&= K(x|l(x)) + log(l(x)) + 2 \log\log l(x) +4 \le^+ K(x|l(x)) + log(l(x)) + 2 \log\log l(x). \text{ Всё.}}


(d) Покажем, что $K(x,x) \le^+ K(x) \le^+ K(x,x)$. Первое неравенство: если $A(p)=x, l(p)=K(x)$, то $B(p)=(A(p), A(p))=(x,x)$, тогда  $K(x,x)\le^+ K_B(x,x)\le l(p)=K(x)$. Второе неравенство: если $A(p)=(x,x), l(p)=K(x)$ , то $B(p)=(x,x).first$, тогда  $K(x)\le^+ K_B(x)\le l(p)=K(x,x).$ Всё.

Теперь $K(x,K(x)) \le^+ K(x) \le^+ K(x,K(x))$. Второе неравенство: если $A(p)=(x,K(x)), l(p)=K(x,K(x))$, то $B(p)=A(p).first=x$, тогда  $K(x)\le^+ K_B(x)\le l(p)=K(x,K(x))$. Первое неравенство: если $A(p)=x, l(p)=K(x)$, то $B(p)=(A(p),l(p))=(x,K(x))$, тогда  $K(x,K(x))\le^+ K_B(x)\le l(p)=K(x)$.

(e) Покажем, что $K(x0) \le^+ K(x) \le^+ K(x0)$. Первое неравенство: если $A(p)=x, l(p)=K(x)$, то $B(p)=A(p)0=x0$, тогда  $K(x0)\le^+ K_B(x0)\le l(p)=K(x)$. Второе неравенство: если $A(p)=x0, l(p)=K(x0)$, то $B(p)=A(p)/2=x$, тогда  $K(x)\le^+ K_B(x)\le l(p)=K(x0).$ Всё.

Покажем, что $K(0x) \le^+ K(x) \le^+ K(0x)$. Первое неравенство: если $A(p)=x, l(p)=K(x)$, то $B(p)=0A(p)=0x$, тогда $K(0x)\le^+ K_B(0x)\le l(p)=K(x)$. Второе неравенство: если $A(p)=0x, l(p)=K(0x)$, то $B(p)=A(p)\%(2^{l(A(p))-1})=x$, тогда  $K(x)\le^+ K_B(x)\le l(p)=K(x0).$ Всё.

Еще два равенства устанавливаются полностью аналогично.

(f) Покажем, что $K(x|y0) \le^+ K(x|y) \le^+ K(x|y0)$. Первое неравенство: если $B(p,y)=x, l(p)=K(x|y)$, то $A(p,y0)=B(p,(y0)/2)=x$, тогда  $K(x|y0)\le^+ K_A(x|y0)\le l(p)=K(x|y)$. Второе неравенство: если $B(p,y0)=x, l(p)=K(x|y0)$, то $A(p,y) = B(p,(y0)/2) = x$, тогда  $K(x|y)\le^+ K_A(x|y)\le l(p)=K(x|y0).$ Всё.

Еще три равенства устанавливаются полностью аналогично.


\task{1.2}
Будь оптимальный алгоритм всюду определен, сложность слова была бы вычислима, что неверно. В самом деле, можно, например, рассмотреть машину, которая на n--м этапе своей работы делает $2^n$ шагов работы оптимального алгоритма на каждом из бинарных слов длины не более $n$ и, если на одном из этих слов одно из вычислений завершилось и его результат совпал с кодируемым словом, а длина входого слова оказалась меньше всех ранее обнаруженных, то следует запомнить эту длину. Тем самым, мы обязательно встретим оптимальное описание кодируемого слова (вместе с его длиной, разумеется).

\task{1.3} 
Лекционный материал. Также можно найти в книге В.\,А.\,Успенского, Н.\,К.\,Верещагина, А.\,Шеня <<Колмогоровская сложность и алгоритмическая случайность>>. Теоремы 6 и 8а). Правда, рассуждения теоремы 6 следует немного продолжить: из ограниченности ограничивающей снизу функции следует, что её поточечный предел не может быть равен сложности (см. задачу 1.1b), поэтому такой функции не существует.


\task{1.4} 
Рассмотрим все возможные пары бинарных слов, сумма длин которых равна $N$: $D_N=\{ (\alpha,\beta)\in\left(\{0,1\}^*\right)^2 \colon l(\alpha)+l(\beta)=N \}$. Таких пар всего $|D_N|=(N+1)2^N$. Тогда $\exists (x,y)\in D_N \colon K(x,y)\ge \lfloor\log |D_N|\rfloor > N+\log (N+1)-1 > N+\log N -1.$ Всё.


\task{1.5}
Пусть $x'$ отличается от $x$ в $i$-ой позиции. Пусть $A(p)=x, K(x)=l(p)$. Рассмотрим алгоритм: $B\left(\overline{bin(l(bin(i)))}01bin(i)p\right)=x'$ (по соответствующему правилу). Тогда $$K(x')\le^+2l(bin(l(bin(i))))+2+l(bin(i))+l(p)\le K(x)+\log n + 2\log\log n,\text{ т.к. }i\le n.$$ Отметим, что, заменив еще раз этот же бит в $x'$, получим $x$, поэтому $K(x)\le^+ K(x')+\log n + 2\log\log n$.


\task{1.6}
Немного (не до конца) формализуем задачу: требуется доказать, что  
\begin{multline*}
\forall \,c>0\; \exists \,\alpha>0 \; \forall \,x \; \left(K(x)\ge n-c , x=yz , l(y)=l(z)=\frac n2 \right ) 
\Rightarrow \\ \Rightarrow
\left( K(y)\ge \frac n2-\alpha \log n\right)\: \bigwedge \: \left(K(z)\ge \frac n2-\alpha \log n\right).
\end{multline*}
Предположим, что верно противное:
\begin{multline*}
\exists \,c>0\; \forall \,\alpha>0 \; \exists \,x \; \left(K(x)\ge n-c, x=yz, l(y)=l(z)=\frac n2 \right) 
\: \bigwedge \\ \bigwedge \: \left(\left( K(y)<  \frac n2-\alpha \log n\right) \bigvee \left( K(z)<  \frac n2-\alpha \log n\right) \right).
\end{multline*}
Тогда для такого $c$ при произвольном $\alpha$ найдется такое $x$, состоящее из двух равных частей, что для них выполнена дизъюнкция. Пусть, без ограничения общности, верно неравенство с $y$. Имеем:
\begin{multline*} 
n-c < K(x) = K(yz) \le K(y,z) \le K(y)+K(z)+2\log \frac n2 + \tilde c <\\< \frac n2 -(\alpha-2)\log n + K(z) +\tilde c \Rightarrow K(z) > \frac n2 +(\alpha-2)\log n + \hat c,
\end{multline*}
где $\hat c$ не зависит от $x$ и $\alpha$.
Причем такое $x$, а значит и $z$, существует при сколь угодно больших $\alpha$. Однако хорошо известно, что сложность слова ограничена сверху $K(z)\le^+ l(z)=n/2$ (стоит отметить, что, вообще говоря, здесь $n$ совсем не обязано быть большим да и вообще возрастать, нам же будет достаточно лишь, чтобы $n\ge2$), а значит оценка снизу, полученная в нашем предположении, является неверным вместе со всем предположением. Противоречие получено, утверждение доказано.


\task{1.7} 
Утверждение очевидно. Имея алгоритм вычисления последовательности $A(k)=\omega_k$, построим алгоритм $B(n)=c_1c_2\ldots c_n$, где $c_k=\omega_k=A(k)$. Поэтому $K(\omega_1\ldots\omega_n)\le^+K_B(\omega_1\ldots\omega_n)=K(n)$. Это раз. Взяв $\hat B(bin(n))=c_1c_2\ldots c_n$, где $c_k=\omega_k=A(k)$,  получим $K(\omega_1\ldots\omega_n)\le^+K_{\hat B}(\omega_1\ldots\omega_n)\le l(bin(n))<\log n +1$. Это два. И наконец $\tilde B(\omega_1\ldots\omega_n,n)=B(\Lambda,n) \Rightarrow K(\omega_1\ldots\omega_n|n)=^+0$ (ср. с 1.1а).


\task{1.8}
Известно, что $\foral{n} K(\omega^n|n)< C.$ Построим конечные вычислимые множества: $\hat C_n = \{x\colon l(x)=n, K(x|n) < C\}.$ $\omega \in \bigcap\limits_n\bigcup\limits_{x\in\hat C_n} \Gamma_x$, $\foral{n}|C_n| \le 2^C$. Построим на их основе множества $ C_n:$ $\hat C_1 = C_1,$
$$C_{n+1} = \{y\in \hat C_{n+1}\colon\exist{x\in C_n} x\subset y\}, \omega \in \bigcap\limits_n\bigcup\limits_{x\in C_n} \Gamma_x, \foral{n}|\hat C_n|\le|C_n| \le 2^C.$$
Рассмотрим дерево бесконечных двоичных последовательностей $\Omega$ до глубины $n$: $l_n$~--- число вершин $C_n$ левее (меньше лексикографически) $\omega^n$ и $r_n$~--- число вершин $C_n$ правее $\omega^n$. $L=\overline{\lim\limits_{n\rightarrow\infty}} l_n$, $R=\overline{\lim\limits_{n\rightarrow\infty}} r_n, L\le2^C, R\le2^C$. Тогда $\foral{n} l_n \le L, r_n\le R,$ причем равенство достигается при бесконечном числе $n$, ведь $l_n, r_n$ дискретны. Для вычисления $\omega^N$ возьмем $m\ge n\ge N$,  такие, что $\colon l_n=L, r_m = R$. Для этого их можно искать перебирая по возрастанию их суммы. Выбрав конкретные $m, n$, перебираем все возможные $\omega^n$ на предмет того, действительно ли $C_n, C_m$ порождают числа $L,R$. Если да~--- мы нашли $\omega^N$, нет~--- продолжаем. Перебор конечен (но не ограничен сверху), последовательность вычислима.

\task{1.9} 
Если бесконечная последовательность вычислима $\omega = \omega_1\omega_2\ldots$, то существует алгоритм $A(n)=\omega_n$. Рассмотрим алгоритм $\forall \: p B(p,n)=A(1)A(2)\ldots A(n)=\omega_1\ldots \omega_n=\omega^n$. Имеем, положив $p=\Lambda$: $K(\omega^n|n)\le^+ K_B(\Lambda,n) = 0 \Rightarrow \sup\limits_{n}(\omega^n|n)\le c <\infty$. 

Обратно:  $\sup\limits_{n}(\omega^n|n)\le c <\infty \Rightarrow K(\omega^n|n)<c$. По результату задачи 1.8 последовательность будет вычислима.

Таких последовательностей конечное число, поскольку каждой паре $(L,R)$, а их не более $2^{2C}$ соответствует не более 1 последовательности (проблема доказательства в задаче 1.8 в том, что мы не знаем сами эти числа, но можем перебрать).


\task{1.15}
Для вычисление $\alpha^n$ рассмотрим следующий алгоритм. Запустим алгоритм перечисления элементов множества А и будем постепенно расставлять единицы в характеристическую последовательность. При этом в $\alpha^n$ также будут записываться единицы, а в некоторый момент перестанут, поскольку все элементы с номерами не большими $n$ будут перечислены. В этот самый момент машине следует указать, что надо остановиться. Как это сделать: указать машине, сколько единиц следует поставить в $\alpha^n$, это число вполне фиксировано, правда, невычислимо (что не мешает нам дать его на вход машине). Поэтому $K(\alpha^n|n)\le^+K(n)\le \log n$ ($n$ требуется для определения длины последовательности).

Если последовательность вычислима, мы можем вообще ничего не сообщать алгоритму --- он сам может проверить, лежат ли в множестве первые $n$ элементов, после чего остановится.

Если 

